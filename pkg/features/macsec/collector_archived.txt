// SPDX-License-Identifier: MIT

// this plugin for macsec will collect metrics from the command "show security macsec connections"
// and in future maybe from the command "show security macsec statistics" as well
package macsec

import (
	"fmt"
	"github.com/czerwonk/junos_exporter/pkg/collector"
	"github.com/pkg/errors"
	"github.com/prometheus/client_golang/prometheus"
	"strconv"
	"strings"
)

const prefix string = "junos_macsec_"

// Metrics to collect for the feature
var (
	macsecConnectionInformationDesc      *prometheus.Desc
	macsecInterfaceCommonInformationDesc *prometheus.Desc
	macsecOffsetDesc                     *prometheus.Desc
	macsecInboundPacketsDesc             *prometheus.Desc
	macsecOutboundPacketsDesc            *prometheus.Desc
	interfaceNameDesc                    *prometheus.Desc
	connectivityAssociationNameDesc      *prometheus.Desc
	cipherSuiteDesc                      *prometheus.Desc
	encryptionDesc                       *prometheus.Desc
	offsetDesc                           *prometheus.Desc
	includeSCIDesc                       *prometheus.Desc

	/*
		interfaceAmountDesc *prometheus.Desc
		interfaceNameDesc   *prometheus.Desc
		connectionNameDesc  *prometheus.Desc
		cipherDesc          *prometheus.Desc
		statusDesc          *prometheus.Desc
		channelNameDesc     *prometheus.Desc
		channelSCIdDesc     *prometheus.Desc
		channelStatusDesc   *prometheus.Desc

	*/
)

func init() {
	l := []string{"connection_info"}
	macsecConnectionInformationDesc = prometheus.NewDesc(prefix+"connection_info", "Interfaces that have macsec", l, nil)
	macsecInterfaceCommonInformationDesc = prometheus.NewDesc(prefix+"amount_of_connections", "Information of specific interface", l, nil)
	macsecOffsetDesc = prometheus.NewDesc(prefix+"offset", "information regarding the offset", l, nil)
	macsecInboundPacketsDesc = prometheus.NewDesc(prefix+"inbound_packets", "Information of inbound packets", l, nil)
	macsecOutboundPacketsDesc = prometheus.NewDesc(prefix+"outbound_packets", "Information of outbound packets", l, nil)
	/*
		l := []string{"interface_name", "ca_name", "sc_id"}
		interfaceNameDesc = prometheus.NewDesc(prefix+"interface_name", "Name of the interface", l, nil)
		connectionNameDesc = prometheus.NewDesc(prefix+"connection_name", "Name of the connection", l, nil)
		cipherDesc = prometheus.NewDesc(prefix+"cipher_suite", "Cipher suite used", l, nil)
		statusDesc = prometheus.NewDesc(prefix+"status", "Status of the secure association", append(l, "direction"), nil)
		channelNameDesc = prometheus.NewDesc(prefix+"channel_name", "Name of a specific channel", l, nil)
		channelSCIdDesc = prometheus.NewDesc(prefix+"channel_scid", "SC Id of a specific channel", l, nil)
		channelStatusDesc = prometheus.NewDesc(prefix+"channel_status", "Status of a specific channel", l, nil)
	*/
}

// macsecCollector collects MACsec metrics
type macsecCollector struct{}

// NewCollector creates a new collector
func NewCollector() collector.RPCCollector {
	return &macsecCollector{}
}

// Name returns the name of the collector
func (*macsecCollector) Name() string {
	return "MACsec"
}

// Describe describes the metrics
func (*macsecCollector) Describe(ch chan<- *prometheus.Desc) {
	ch <- macsecConnectionInformationDesc
	ch <- macsecInterfaceCommonInformationDesc
	ch <- macsecOffsetDesc
	ch <- macsecInboundPacketsDesc
	ch <- macsecOutboundPacketsDesc
}

// Collect collects metrics from JunOS
func (c *macsecCollector) Collect(client collector.Client, ch chan<- prometheus.Metric, labelValues []string) error {
	fmt.Print("inside Collect in MACSec")
	var x = result{}
	//run command and parse will parse an output of juniper command as XML
	//the struct of data for the feature in rpc.go should have similar struct as the parsed XML
	err := client.RunCommandAndParse("show security macsec connections", &x)
	if err != nil {
		fmt.Printf("\n inside error \n")
		return err
	}
	fmt.Printf("x is %v", x)
	fmt.Printf("Number of Outbound packets is %d", x.MacsecConnectionInformation.OutboundSecureChannel[0].OutgoingPacketNumber)
	c.collectForSessions(x, ch, labelValues)
	/*
		for _, t := range x.Information.Sessions {
			c.collectForSessions(t, ch, labelValues)
		}
	*/
	return nil
}

func (c *macsecCollector) collectForSessions(sessions result, ch chan<- prometheus.Metric, labelValues []string) {
	l := append(labelValues)
	fmt.Printf("Amount of sessions is %d \n", len(sessions.MacsecConnectionInformation.MacsecInterfaceCommonInformation))
	ch <- prometheus.MustNewConstMetric(macsecInterfaceCommonInformationDesc, prometheus.GaugeValue, float64(len(sessions.MacsecConnectionInformation.MacsecInterfaceCommonInformation)), l...)
	for _, interfaceInfo := range sessions.MacsecConnectionInformation.OutboundSecureChannel {
		//ch <- prometheus.MustNewConstMetric(macsecOffsetDesc, prometheus.GaugeValue, float64(interfaceInfo.), l...)
		pn, err := getPacketsNumber(interfaceInfo.OutgoingPacketNumber)
		if err != nil {
			fmt.Printf("\n packet number is non numerical. Maybe unmarshaling issues \n")
		}

		ch <- prometheus.MustNewConstMetric(macsecOutboundPacketsDesc, prometheus.GaugeValue, float64(pn), l...)

	}
	//ch <- prometheus.MustNewConstMetric(macsecOffsetDesc, prometheus.GaugeValue, float64(sessions.MacsecConnectionInformation.MacsecInterfaceCommonInformation[0].Offset), l...)
}

// []string is array of strings
/*
func (c *macsecCollector) collectForSessions(session sessionInfos, ch chan<- prometheus.Metric, labelValues []string) {
	l := append(labelValues, session.ConnectionName)

	ch <- prometheus.MustNewConstMetric(interfaceNameDesc, prometheus.GaugeValue, float64(session.InterfaceName), l...)
	ch <- prometheus.MustNewConstMetric(connectionNameDesc, prometheus.GaugeValue, float64(session.ConnectionName), l...)
	ch <- prometheus.MustNewConstMetric(cipherDesc, prometheus.GaugeValue, float64(session.Cipher), l...)
	//ch <- prometheus.MustNewConstMetric(ChannelInfo, prometheus.GaugeValue, float64(session.ChannelInfo), l...)

	for _, channel := range session.ChannelInfo {
		lp := append(l, channel.Name)
		ch <- prometheus.MustNewConstMetric(channelSCIdDesc, prometheus.GaugeValue, float64(proto.Routes), lp...)
		ch <- prometheus.MustNewConstMetric(protocolActiveRoutes, prometheus.GaugeValue, float64(proto.ActiveRoutes), lp...)
	}
}
*/
// collectSecureAssociations collects metrics for secure associations
/*
func (c *macsecCollector) collectSecureAssociations(associations []SecureAssociation, ch chan<- prometheus.Metric, labelValues []string) {
	for _, sa := range associations {
		ch <- prometheus.MustNewConstMetric(statusDesc, prometheus.GaugeValue, stateToFloat(sa.Status), labelValues...)
	}
}
*/
// stateToFloat converts the status string to a float value
func stateToFloat(status string) float64 {
	if status == "inuse" {
		return 1
	}
	return 0
}

func getNumberOfConnections(connections []string) (int, error) {
	if len(connections) == 0 {
		return 0, errors.New("No connections")
	} else {
		return len(connections), nil
	}
}

/*
// parseXML parses the XML response
func parseXML(b []byte, res *MultiConnectionResult) error {
	// Here we would implement the logic to parse the specific XML format
	// For now, we will assume the XML is directly unmarshallable into the structure
	return xml.Unmarshal(b, res)
}
*/

func getInterfaceNumber(nameAsString string) (int, error) {
	result := strings.SplitAfter(nameAsString, "/")
	fmt.Print("\n returned value is %s", result[len(result)-1])
	i, err := strconv.Atoi(result[len(result)-1])
	if err != nil {
		return 0, err
	}
	return i, nil
}

func getPacketsNumber(packetsAsString string) (int, error) {
	fmt.Printf("\n received value in packetNumber is %s", packetsAsString)
	i, err := strconv.Atoi(packetsAsString)
	if err != nil {
		return 0, err
	}
	fmt.Printf("\n returned value in packetNumber is %d", i)
	return i, nil
}
